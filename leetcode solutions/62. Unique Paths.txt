'''
62. Unique Paths

https://leetcode.com/problems/unique-paths/

There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.

Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.

The test cases are generated so that the answer will be less than or equal to 2 * 10^9.

Example 1:
<diagram here>
Input: m = 3, n = 7
Output: 28

Example 2:
Input: m = 3, n = 2
Output: 3
Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
1. Right -> Down -> Down
2. Down -> Down -> Right
3. Down -> Right -> Down

Constraints:
- 1 <= m, n <= 100
'''

class Solution:
    def uniquePaths(self, m, n):
        def explore(i, j, end_i, end_j):
            # base/corner cases
            if i == end_i and j == end_j:
                return 1
            if i > end_i or j > end_j:
                return 0
            
            # main case
            explore_left = explore(i+1, j, end_i, end_j)
            explore_down = explore(i, j+1, end_i, end_j)
            return explore_left + explore_down

        # base/corner cases
        if m <= 0 or n <= 0:
            return 0

        # main case
        return explore(0, 0, m-1, n-1)


sln = Solution()
m,n = 3,7
print(sln.uniquePaths(m,n))